{
  "version": 3,
  "sources": ["index.node.js"],
  "sourcesContent": ["import { Readable, Transform, Writable } from 'node:stream'\nimport { pipeline as pipelinePromise } from 'node:stream/promises'\nimport { setTimeout } from 'node:timers/promises'\nimport cloneable from 'cloneable-readable'\n\nexport const pipeline = async (streams, streamOptions = {}) => {\n  for (let idx = 0, l = streams.legnth; idx < l; idx++) {\n    if (typeof streams[idx].then === 'function') {\n      throw new Error(`Promise instead of stream passed in at index ${idx}`)\n    }\n  }\n  // Ensure stream ends with only writable\n  const lastStream = streams[streams.length - 1]\n  if (isReadable(lastStream)) {\n    streamOptions.objectMode = lastStream._readableState.objectMode\n    streams.push(createWritableStream(() => {}, streamOptions))\n  }\n  await pipelinePromise(streams, streamOptions)\n  return result(streams)\n}\n\nexport const pipejoin = (streams) => {\n  return streams.reduce((pipeline, stream, idx) => {\n    if (typeof stream.then === 'function') {\n      throw new Error(`Promise instead of stream passed in at index ${idx}`)\n    }\n    return pipeline.pipe(stream)\n  })\n}\n\nexport const result = async (streams) => {\n  const output = {}\n  for (const stream of streams) {\n    if (typeof stream.result === 'function') {\n      const { key, value } = await stream.result()\n      if (key) {\n        output[key] = value\n      }\n    }\n  }\n  return output\n}\n\n// Not possible in WebStream\nexport const backpressureGuage = (streams) => {\n  const keys = Object.keys(streams)\n  const values = Object.values(streams)\n  const metrics = {}\n  for (let i = 0, l = values.length; i < l; i++) {\n    const value = values[i]\n    metrics[keys[i]] = { timeline: [], total: {} }\n    let timestamp\n    let startTimestamp\n    value.on('pause', () => {\n      timestamp = Date.now() // process.hrtime.bigint()\n    })\n    value.on('resume', () => {\n      if (timestamp) {\n        // Number.parseInt(  (process.hrtime.bigint() - pauseTimestamp).toString()  ) / 1_000_000 // ms\n        const duration = Date.now() - timestamp\n        metrics[keys[i]].timeline.push({ timestamp, duration })\n      } else {\n        startTimestamp = Date.now()\n      }\n    })\n    value.on('end', () => {\n      const duration = Date.now() - startTimestamp\n      metrics[keys[i]].total = { timestamp: startTimestamp, duration }\n    })\n  }\n  return metrics\n}\n\nexport const streamToArray = async (stream) => {\n  const value = []\n  for await (const chunk of stream) {\n    value.push(chunk)\n  }\n  return value\n}\n\nexport const streamToObject = async (stream) => {\n  const value = {}\n  for await (const chunk of stream) {\n    Object.assign(value, chunk)\n  }\n  return value\n}\n\nexport const streamToString = async (stream) => {\n  let value = ''\n  for await (const chunk of stream) {\n    value += chunk\n  }\n  return value\n}\n\nexport const streamToBuffer = async (stream) => {\n  const value = []\n  for await (const chunk of stream) {\n    value.push(Buffer.from(chunk))\n  }\n  return Buffer.concat(value)\n}\n\nexport const isReadable = (stream) => {\n  return !!stream._readableState\n}\n\nexport const isWritable = (stream) => {\n  return !!stream._writableState\n}\n\nexport const makeOptions = ({\n  highWaterMark,\n  chunkSize,\n  objectMode,\n  signal,\n  ...streamOptions\n} = {}) => {\n  objectMode ??= true\n  return {\n    writableHighWaterMark: highWaterMark,\n    writableObjectMode: objectMode,\n    readableObjectMode: objectMode,\n    readableHighWaterMark: highWaterMark,\n    highWaterMark,\n    chunkSize,\n    objectMode,\n    signal,\n    ...streamOptions\n  }\n}\n\nexport const createReadableStream = (input = '', streamOptions) => {\n  // string doesn't chunk, and is slow\n  if (typeof input === 'string') {\n    function * iterator (input) {\n      const size = streamOptions?.chunkSize ?? 16 * 1024\n      let position = 0\n      const length = input.length\n      while (position < length) {\n        yield input.substring(position, position + size)\n        position += size\n      }\n    }\n    return Readable.from(iterator(input), streamOptions)\n  }\n  return Readable.from(input, streamOptions)\n}\n\nexport const createPassThroughStream = (\n  passThrough = (chunk) => chunk,\n  flush,\n  streamOptions\n) => {\n  if (typeof flush !== 'function') {\n    streamOptions = flush\n    flush = undefined\n  }\n  return new Transform({\n    ...makeOptions(streamOptions),\n    async transform (chunk, encoding, callback) {\n      try {\n        await passThrough(chunk)\n        this.push(chunk)\n        callback()\n      } catch (e) {\n        callback(e)\n      }\n    },\n    async flush (callback) {\n      try {\n        if (flush) {\n          await flush()\n        }\n        callback()\n      } catch (e) {\n        callback(e)\n      }\n    }\n  })\n}\n\nexport const createTransformStream = (\n  transform = (chunk, enqueue) => enqueue(chunk),\n  flush,\n  streamOptions\n) => {\n  if (typeof flush !== 'function') {\n    streamOptions = flush\n    flush = undefined\n  }\n  return new Transform({\n    ...makeOptions(streamOptions),\n    async transform (chunk, encoding, callback) {\n      const enqueue = (chunk, encoding) => {\n        this.push(chunk, encoding)\n      }\n      try {\n        await transform(chunk, enqueue)\n        callback()\n      } catch (e) {\n        callback(e)\n      }\n    },\n    async flush (callback) {\n      try {\n        if (flush) {\n          const enqueue = (chunk, encoding) => {\n            this.push(chunk, encoding)\n          }\n          await flush(enqueue)\n        }\n        callback()\n      } catch (e) {\n        callback(e)\n      }\n    }\n  })\n}\n\nexport const createWritableStream = (\n  write = () => {},\n  final,\n  streamOptions\n) => {\n  if (typeof final !== 'function') {\n    streamOptions = final\n    final = undefined\n  }\n  return new Writable({\n    ...makeOptions(streamOptions),\n    async write (chunk, encoding, callback) {\n      try {\n        await write(chunk)\n        callback()\n      } catch (e) {\n        callback(e)\n      }\n    },\n    async final (callback) {\n      try {\n        if (final) {\n          await final()\n        }\n        callback()\n      } catch (e) {\n        callback(e)\n      }\n    }\n  })\n}\n\nexport const createBranchStream = (\n  { streams, resultKey } = {},\n  streamOptions\n) => {\n  const stream = cloneable(createPassThroughStream(undefined, streamOptions))\n  streams.unshift(stream.clone())\n  const value = pipeline(streams, streamOptions)\n  stream.result = async () => {\n    return {\n      key: resultKey ?? 'branch',\n      value: await value\n    }\n  }\n  return stream\n}\n\n/* export const tee = (sourceStream) => {\n  const stream = cloneable(sourceStream)\n  return [stream, stream.clone()]\n} */\n\nexport const timeout = (ms, { signal } = {}) => {\n  return setTimeout(ms, { signal })\n}\n"],
  "mappings": "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",
  "names": ["pipeline", "input", "chunk", "encoding"]
}
