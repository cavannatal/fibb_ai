import { Readable, Transform, Writable } from "node:stream";
import { pipeline as pipelinePromise } from "node:stream/promises";
import { setTimeout } from "node:timers/promises";
import cloneable from "cloneable-readable";
const pipeline = async (streams, streamOptions = {}) => {
  for (let idx = 0, l = streams.legnth; idx < l; idx++) {
    if (typeof streams[idx].then === "function") {
      throw new Error(`Promise instead of stream passed in at index ${idx}`);
    }
  }
  const lastStream = streams[streams.length - 1];
  if (isReadable(lastStream)) {
    streamOptions.objectMode = lastStream._readableState.objectMode;
    streams.push(createWritableStream(() => {
    }, streamOptions));
  }
  await pipelinePromise(streams, streamOptions);
  return result(streams);
};
const pipejoin = (streams) => {
  return streams.reduce((pipeline2, stream, idx) => {
    if (typeof stream.then === "function") {
      throw new Error(`Promise instead of stream passed in at index ${idx}`);
    }
    return pipeline2.pipe(stream);
  });
};
const result = async (streams) => {
  const output = {};
  for (const stream of streams) {
    if (typeof stream.result === "function") {
      const { key, value } = await stream.result();
      if (key) {
        output[key] = value;
      }
    }
  }
  return output;
};
const backpressureGuage = (streams) => {
  const keys = Object.keys(streams);
  const values = Object.values(streams);
  const metrics = {};
  for (let i = 0, l = values.length; i < l; i++) {
    const value = values[i];
    metrics[keys[i]] = { timeline: [], total: {} };
    let timestamp;
    let startTimestamp;
    value.on("pause", () => {
      timestamp = Date.now();
    });
    value.on("resume", () => {
      if (timestamp) {
        const duration = Date.now() - timestamp;
        metrics[keys[i]].timeline.push({ timestamp, duration });
      } else {
        startTimestamp = Date.now();
      }
    });
    value.on("end", () => {
      const duration = Date.now() - startTimestamp;
      metrics[keys[i]].total = { timestamp: startTimestamp, duration };
    });
  }
  return metrics;
};
const streamToArray = async (stream) => {
  const value = [];
  for await (const chunk of stream) {
    value.push(chunk);
  }
  return value;
};
const streamToObject = async (stream) => {
  const value = {};
  for await (const chunk of stream) {
    Object.assign(value, chunk);
  }
  return value;
};
const streamToString = async (stream) => {
  let value = "";
  for await (const chunk of stream) {
    value += chunk;
  }
  return value;
};
const streamToBuffer = async (stream) => {
  const value = [];
  for await (const chunk of stream) {
    value.push(Buffer.from(chunk));
  }
  return Buffer.concat(value);
};
const isReadable = (stream) => {
  return !!stream._readableState;
};
const isWritable = (stream) => {
  return !!stream._writableState;
};
const makeOptions = ({
  highWaterMark,
  chunkSize,
  objectMode,
  signal,
  ...streamOptions
} = {}) => {
  objectMode ??= true;
  return {
    writableHighWaterMark: highWaterMark,
    writableObjectMode: objectMode,
    readableObjectMode: objectMode,
    readableHighWaterMark: highWaterMark,
    highWaterMark,
    chunkSize,
    objectMode,
    signal,
    ...streamOptions
  };
};
const createReadableStream = (input = "", streamOptions) => {
  if (typeof input === "string") {
    function* iterator(input2) {
      const size = streamOptions?.chunkSize ?? 16 * 1024;
      let position = 0;
      const length = input2.length;
      while (position < length) {
        yield input2.substring(position, position + size);
        position += size;
      }
    }
    return Readable.from(iterator(input), streamOptions);
  }
  return Readable.from(input, streamOptions);
};
const createPassThroughStream = (passThrough = (chunk) => chunk, flush, streamOptions) => {
  if (typeof flush !== "function") {
    streamOptions = flush;
    flush = void 0;
  }
  return new Transform({
    ...makeOptions(streamOptions),
    async transform(chunk, encoding, callback) {
      try {
        await passThrough(chunk);
        this.push(chunk);
        callback();
      } catch (e) {
        callback(e);
      }
    },
    async flush(callback) {
      try {
        if (flush) {
          await flush();
        }
        callback();
      } catch (e) {
        callback(e);
      }
    }
  });
};
const createTransformStream = (transform = (chunk, enqueue) => enqueue(chunk), flush, streamOptions) => {
  if (typeof flush !== "function") {
    streamOptions = flush;
    flush = void 0;
  }
  return new Transform({
    ...makeOptions(streamOptions),
    async transform(chunk, encoding, callback) {
      const enqueue = (chunk2, encoding2) => {
        this.push(chunk2, encoding2);
      };
      try {
        await transform(chunk, enqueue);
        callback();
      } catch (e) {
        callback(e);
      }
    },
    async flush(callback) {
      try {
        if (flush) {
          const enqueue = (chunk, encoding) => {
            this.push(chunk, encoding);
          };
          await flush(enqueue);
        }
        callback();
      } catch (e) {
        callback(e);
      }
    }
  });
};
const createWritableStream = (write = () => {
}, final, streamOptions) => {
  if (typeof final !== "function") {
    streamOptions = final;
    final = void 0;
  }
  return new Writable({
    ...makeOptions(streamOptions),
    async write(chunk, encoding, callback) {
      try {
        await write(chunk);
        callback();
      } catch (e) {
        callback(e);
      }
    },
    async final(callback) {
      try {
        if (final) {
          await final();
        }
        callback();
      } catch (e) {
        callback(e);
      }
    }
  });
};
const createBranchStream = ({ streams, resultKey } = {}, streamOptions) => {
  const stream = cloneable(createPassThroughStream(void 0, streamOptions));
  streams.unshift(stream.clone());
  const value = pipeline(streams, streamOptions);
  stream.result = async () => {
    return {
      key: resultKey ?? "branch",
      value: await value
    };
  };
  return stream;
};
const timeout = (ms, { signal } = {}) => {
  return setTimeout(ms, { signal });
};
export {
  backpressureGuage,
  createBranchStream,
  createPassThroughStream,
  createReadableStream,
  createTransformStream,
  createWritableStream,
  isReadable,
  isWritable,
  makeOptions,
  pipejoin,
  pipeline,
  result,
  streamToArray,
  streamToBuffer,
  streamToObject,
  streamToString,
  timeout
};
