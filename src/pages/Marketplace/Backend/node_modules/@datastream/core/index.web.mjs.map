{
  "version": 3,
  "sources": ["index.web.js"],
  "sourcesContent": ["/* global ReadableStream, TransformStream, WritableStream */\n\nexport const pipeline = async (streams, streamOptions = {}) => {\n  // Ensure stream ends with only writable\n  const lastStream = streams[streams.length - 1]\n  if (isReadable(lastStream)) {\n    streams.push(createWritableStream(() => {}, streamOptions))\n  }\n\n  await pipejoin(streams)\n  return result(streams)\n}\n\nexport const pipejoin = (streams) => {\n  const lastIndex = streams.length - 1\n  return streams.reduce((pipeline, stream, idx) => {\n    if (typeof stream.then === 'function') {\n      throw new Error(`Promise instead of stream passed in at index ${idx}`)\n    }\n    if (idx === lastIndex && stream.getWriter) {\n      return pipeline.pipeTo(stream)\n    }\n    return pipeline.pipeThrough(stream)\n  })\n}\n\nexport const result = async (streams) => {\n  const output = {}\n  for (const stream of streams) {\n    if (typeof stream.result === 'function') {\n      const { key, value } = await stream.result()\n      if (key) {\n        output[key] = value\n      }\n    }\n  }\n  return output\n}\n\nexport const streamToArray = async (stream) => {\n  const value = []\n  for await (const chunk of stream) {\n    value.push(chunk)\n  }\n  return value\n}\n\nexport const streamToObject = async (stream) => {\n  const value = {}\n  for await (const chunk of stream) {\n    Object.assign(value, chunk)\n  }\n  return value\n}\n\nexport const streamToString = async (stream) => {\n  let value = ''\n  for await (const chunk of stream) {\n    value += chunk\n  }\n  return value\n}\n\n/* export const streamToBuffer = async (stream) => {\n  let byteLength = 0\n  let value = []\n  for await (const chunk of stream) {\n    byteLength += chunk.length\n    value.push([new Uint8Array(chunk),byteLength])\n  }\n  return value.reduce((buffer, set) => {\n    if (!buffer) buffer = new Uint8Array(byteLength)\n    buffer.set(...set)\n    return buffer\n  })\n} */\n\nexport const isReadable = (stream) => {\n  return typeof stream.pipeTo === 'function' || !!stream.readable // TODO find better solution\n}\n\nexport const isWritable = (stream) => {\n  return typeof stream.pipeTo === 'undefined' || !!stream.writable // TODO find better solution\n}\n\nexport const makeOptions = ({\n  highWaterMark,\n  chunkSize,\n  signal,\n  ...streamOptions\n} = {}) => {\n  return {\n    writableStrategy: {\n      highWaterMark,\n      size: { chunk: chunkSize }\n    },\n    readableStrategy: {\n      highWaterMark,\n      size: { chunk: chunkSize }\n    },\n    signal,\n    ...streamOptions\n  }\n}\n\nexport const createReadableStream = (input, streamOptions) => {\n  const queued = []\n  const stream = new ReadableStream(\n    {\n      async start (controller) {\n        while (queued.length) {\n          const chunk = queued.shift()\n          controller.enqueue(chunk)\n        }\n        if (typeof input === 'string') {\n          const chunkSize = streamOptions?.chunkSize ?? 16 * 1024\n          let position = 0\n          const length = input.length\n          while (position < length) {\n            const chunk = input.substring(position, position + chunkSize)\n            controller.enqueue(chunk)\n            position += chunkSize\n          }\n          controller.close()\n        } else if (Array.isArray(input)) {\n          // TODO update to for(;;) loop, faster\n          for (const chunk of input) {\n            controller.enqueue(chunk)\n          }\n          controller.close()\n        } else if (['function', 'object'].includes(typeof input)) {\n          for await (const chunk of input) {\n            controller.enqueue(chunk)\n          }\n          controller.close()\n        }\n      },\n      pull (controller) {\n        while (queued.length) {\n          const chunk = queued.shift()\n          if (chunk === null) {\n            controller.close()\n          } else {\n            controller.enqueue(chunk)\n          }\n        }\n      }\n    },\n    makeOptions(streamOptions)\n  )\n  stream.push = (chunk) => queued.push(chunk)\n  return stream\n}\n\nexport const createPassThroughStream = (\n  passThrough = (chunk) => {},\n  flush,\n  streamOptions\n) => {\n  if (typeof flush !== 'function') {\n    streamOptions = flush\n    flush = undefined\n  }\n  return new TransformStream(\n    {\n      start () {},\n      async transform (chunk, controller) {\n        await passThrough(chunk)\n        controller.enqueue(chunk)\n      },\n      async flush (controller) {\n        if (flush) {\n          await flush()\n        }\n        controller.terminate()\n      }\n    },\n    makeOptions(streamOptions)\n  )\n}\n\nexport const createTransformStream = (\n  transform = (chunk, enqueue) => enqueue(chunk),\n  flush,\n  streamOptions\n) => {\n  if (typeof flush !== 'function') {\n    streamOptions = flush\n    flush = undefined\n  }\n  return new TransformStream(\n    {\n      start () {},\n      async transform (chunk, controller) {\n        const enqueue = (chunk, encoding) => {\n          controller.enqueue(chunk, encoding)\n        }\n        await transform(chunk, enqueue)\n      },\n      async flush (controller) {\n        if (flush) {\n          const enqueue = (chunk, encoding) => {\n            controller.enqueue(chunk, encoding)\n          }\n          await flush(enqueue)\n        }\n        controller.terminate()\n      }\n    },\n    makeOptions(streamOptions)\n  )\n}\n\nexport const createWritableStream = (\n  write = () => {},\n  close,\n  streamOptions\n) => {\n  if (typeof close !== 'function') {\n    streamOptions = close\n    close = undefined\n  }\n  return new WritableStream(\n    {\n      async write (chunk) {\n        await write(chunk)\n      },\n      async close () {\n        if (close) {\n          await close()\n        }\n      }\n    },\n    makeOptions(streamOptions)\n  )\n}\n\nexport const createBranchStream = (\n  { streams, resultKey } = {},\n  streamOptions\n) => {\n  // TODO refactor, not good enough\n  // https://streams.spec.whatwg.org/#rs-model\n  const branchStream = createReadableStream(undefined, streamOptions)\n  const passThrough = (chunk) => {\n    console.log('push')\n    branchStream.push(chunk)\n  }\n  const flush = () => {\n    console.log('flush')\n    branchStream.push(null)\n  }\n  const stream = createPassThroughStream(passThrough, flush, streamOptions)\n\n  streams.unshift(branchStream)\n  const value = pipeline(streams, streamOptions)\n  stream.result = async () => {\n    return {\n      key: resultKey ?? 'branch',\n      value // await causes: Promise resolution is still pending but the event loop has already resolved\n    }\n  }\n  return stream\n}\n\n/* export const tee = (sourceStream) => {\n  return sourceStream.tee()\n} */\n\n// Polyfill for `import { setTimeout } from 'node:timers/promises'`\nexport const timeout = (ms, { signal } = {}) => {\n  if (signal?.aborted) {\n    return Promise.reject(new Error('Aborted', 'AbortError'))\n  }\n  return new Promise((resolve, reject) => {\n    const abortHandler = () => {\n      clearTimeout(timeout)\n      reject(new Error('Aborted', 'AbortError'))\n    }\n    if (signal) signal.addEventListener('abort', abortHandler)\n    const timeout = setTimeout(() => {\n      resolve()\n      if (signal) signal.removeEventListener('abort', abortHandler)\n    }, ms)\n  })\n}\n"],
  "mappings": "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",
  "names": ["pipeline", "chunk", "timeout"]
}
