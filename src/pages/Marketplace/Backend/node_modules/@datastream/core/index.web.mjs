const pipeline = async (streams, streamOptions = {}) => {
  const lastStream = streams[streams.length - 1];
  if (isReadable(lastStream)) {
    streams.push(createWritableStream(() => {
    }, streamOptions));
  }
  await pipejoin(streams);
  return result(streams);
};
const pipejoin = (streams) => {
  const lastIndex = streams.length - 1;
  return streams.reduce((pipeline2, stream, idx) => {
    if (typeof stream.then === "function") {
      throw new Error(`Promise instead of stream passed in at index ${idx}`);
    }
    if (idx === lastIndex && stream.getWriter) {
      return pipeline2.pipeTo(stream);
    }
    return pipeline2.pipeThrough(stream);
  });
};
const result = async (streams) => {
  const output = {};
  for (const stream of streams) {
    if (typeof stream.result === "function") {
      const { key, value } = await stream.result();
      if (key) {
        output[key] = value;
      }
    }
  }
  return output;
};
const streamToArray = async (stream) => {
  const value = [];
  for await (const chunk of stream) {
    value.push(chunk);
  }
  return value;
};
const streamToObject = async (stream) => {
  const value = {};
  for await (const chunk of stream) {
    Object.assign(value, chunk);
  }
  return value;
};
const streamToString = async (stream) => {
  let value = "";
  for await (const chunk of stream) {
    value += chunk;
  }
  return value;
};
const isReadable = (stream) => {
  return typeof stream.pipeTo === "function" || !!stream.readable;
};
const isWritable = (stream) => {
  return typeof stream.pipeTo === "undefined" || !!stream.writable;
};
const makeOptions = ({
  highWaterMark,
  chunkSize,
  signal,
  ...streamOptions
} = {}) => {
  return {
    writableStrategy: {
      highWaterMark,
      size: { chunk: chunkSize }
    },
    readableStrategy: {
      highWaterMark,
      size: { chunk: chunkSize }
    },
    signal,
    ...streamOptions
  };
};
const createReadableStream = (input, streamOptions) => {
  const queued = [];
  const stream = new ReadableStream(
    {
      async start(controller) {
        while (queued.length) {
          const chunk = queued.shift();
          controller.enqueue(chunk);
        }
        if (typeof input === "string") {
          const chunkSize = streamOptions?.chunkSize ?? 16 * 1024;
          let position = 0;
          const length = input.length;
          while (position < length) {
            const chunk = input.substring(position, position + chunkSize);
            controller.enqueue(chunk);
            position += chunkSize;
          }
          controller.close();
        } else if (Array.isArray(input)) {
          for (const chunk of input) {
            controller.enqueue(chunk);
          }
          controller.close();
        } else if (["function", "object"].includes(typeof input)) {
          for await (const chunk of input) {
            controller.enqueue(chunk);
          }
          controller.close();
        }
      },
      pull(controller) {
        while (queued.length) {
          const chunk = queued.shift();
          if (chunk === null) {
            controller.close();
          } else {
            controller.enqueue(chunk);
          }
        }
      }
    },
    makeOptions(streamOptions)
  );
  stream.push = (chunk) => queued.push(chunk);
  return stream;
};
const createPassThroughStream = (passThrough = (chunk) => {
}, flush, streamOptions) => {
  if (typeof flush !== "function") {
    streamOptions = flush;
    flush = void 0;
  }
  return new TransformStream(
    {
      start() {
      },
      async transform(chunk, controller) {
        await passThrough(chunk);
        controller.enqueue(chunk);
      },
      async flush(controller) {
        if (flush) {
          await flush();
        }
        controller.terminate();
      }
    },
    makeOptions(streamOptions)
  );
};
const createTransformStream = (transform = (chunk, enqueue) => enqueue(chunk), flush, streamOptions) => {
  if (typeof flush !== "function") {
    streamOptions = flush;
    flush = void 0;
  }
  return new TransformStream(
    {
      start() {
      },
      async transform(chunk, controller) {
        const enqueue = (chunk2, encoding) => {
          controller.enqueue(chunk2, encoding);
        };
        await transform(chunk, enqueue);
      },
      async flush(controller) {
        if (flush) {
          const enqueue = (chunk, encoding) => {
            controller.enqueue(chunk, encoding);
          };
          await flush(enqueue);
        }
        controller.terminate();
      }
    },
    makeOptions(streamOptions)
  );
};
const createWritableStream = (write = () => {
}, close, streamOptions) => {
  if (typeof close !== "function") {
    streamOptions = close;
    close = void 0;
  }
  return new WritableStream(
    {
      async write(chunk) {
        await write(chunk);
      },
      async close() {
        if (close) {
          await close();
        }
      }
    },
    makeOptions(streamOptions)
  );
};
const createBranchStream = ({ streams, resultKey } = {}, streamOptions) => {
  const branchStream = createReadableStream(void 0, streamOptions);
  const passThrough = (chunk) => {
    console.log("push");
    branchStream.push(chunk);
  };
  const flush = () => {
    console.log("flush");
    branchStream.push(null);
  };
  const stream = createPassThroughStream(passThrough, flush, streamOptions);
  streams.unshift(branchStream);
  const value = pipeline(streams, streamOptions);
  stream.result = async () => {
    return {
      key: resultKey ?? "branch",
      value
      // await causes: Promise resolution is still pending but the event loop has already resolved
    };
  };
  return stream;
};
const timeout = (ms, { signal } = {}) => {
  if (signal?.aborted) {
    return Promise.reject(new Error("Aborted", "AbortError"));
  }
  return new Promise((resolve, reject) => {
    const abortHandler = () => {
      clearTimeout(timeout2);
      reject(new Error("Aborted", "AbortError"));
    };
    if (signal)
      signal.addEventListener("abort", abortHandler);
    const timeout2 = setTimeout(() => {
      resolve();
      if (signal)
        signal.removeEventListener("abort", abortHandler);
    }, ms);
  });
};
export {
  createBranchStream,
  createPassThroughStream,
  createReadableStream,
  createTransformStream,
  createWritableStream,
  isReadable,
  isWritable,
  makeOptions,
  pipejoin,
  pipeline,
  result,
  streamToArray,
  streamToObject,
  streamToString,
  timeout
};
